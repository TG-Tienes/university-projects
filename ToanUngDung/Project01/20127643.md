# __THÔNG TIN CÁ NHÂN:__ 
## `MSSV: ` __20127643__
## `HỌ VÀ TÊN:` __TRƯƠNG GIA TIẾN__<br><br>
# __Ý TƯỞNG__
## __Về KMEANS__
Về cơ bản, thuật toán KMeans là tìm ra các vị trí tối ưu, chính xác nhất của các centroid để phân cụm.<br>
__Giải thuật:__
1. Khởi tạo k centroid đầu tiên ngẫu nhiên để làm các điểm centroid bắt đầu (initial centroids)
2. Với mỗi pixel có trong ảnh, tính khoảng cách từ pixel đó tới tất cả các centroid và xác định khoảng centroid gần nhất (khoảng cách ngắn nhất tới pixel đó)
3. Tính trung bình cho từng centroid tương ứng với các pixel đã được gán vào các centroid đó
4. Update lại centroid mới tương ứng với các trung bình của nó như đã tính ở bước "3"
5. Lặp lại bước 2-3-4 cho đến khi hết số lần lặp cho phép hoặc khi centroid sau giống hoặc gần giống như centroid trước đó (hội tụ hoặc gần như hội tụ)
6. Gán các pixel với giá trị của các centroid tương ứng với chúng
<br><br>

# __CÁC HÀM__
### Hàm KMEANS
```python
def kmeans(img_1d, k_clusters, max_iter, init_centroids='random'):
    height, width, depth = img_1d.shape
    reshapedIMG = img_1d.reshape(height * width, depth)

    if init_centroids == "random":
        centroids = np.random.choice(255, size=(k_clusters, depth))
    elif init_centroids == "in_pixels":
        centroids = reshapedIMG[np.random.choice(height * width, k_clusters)] 

    for _ in range(max_iter):
        prevCentroid = centroids
        distance = np.zeros((reshapedIMG.shape[0], k_clusters))

        for k in range(k_clusters):
            distance[:,k] = np.square(np.linalg.norm(reshapedIMG - centroids[k,:], axis=1))

        label = np.argmin(distance, axis=1) 
        centroids = np.zeros((k_clusters, depth)) 

        for k in range(k_clusters):
            centroids[k,:] = np.mean(reshapedIMG[label == k,:], axis=0)
        if np.allclose(prevCentroid, centroids, atol=2):
            break
    
    for k in range(k_clusters):
        reshapedIMG[label == k, :] = centroids[k]

    reshapedIMG = reshapedIMG.reshape(height, width, depth)
    return reshapedIMG, centroids
```

### __GIẢI THÍCH HÀM KMEANS__
```python
height, width, depth = img_1d.shape
reshapedIMG = img_1d.reshape(height * width, depth)
```
Đầu tiên ta dùng hàm _`shape`_ trong `numpy` để lấy 3 thông số của ảnh là height (dòng), width (cột), depth (hay còn gọi là channel).<br>
Do ảnh RGB nếu quy ra kiểu array sẽ là mảng 3 chiều (3D) nên trước khi xử lý ta phải dùng hàm _``reshape``_ trong `numpy` để chuyển về thành mảng 2 chiều (2D)



### MAIN
```python
def main():
    imgName = input("Enter image name: ")
    imgName = "img.jpg"
    imgExt = input("Enter image extension: ")

    img = pil.Image.open(imgName)
    npArray = np.array(img)

    k_clus = 19
    newIMG, centroids = kmeans(npArray, k_clusters=k_clus, max_iter=10, init_centroids="in_pixels")
    
    newImgName = imgName.partition(".")[0] + str(k_clus) + "." + imgExt
    plt.imshow(newIMG)

    plt.imsave(newImgName, newIMG)

    print(centroids)
    print(newIMG)
```
<br>

# __HÌNH ẢNH KẾT QUẢ__
## __HÌNH ẢNH GỐC__
![original](img.jpg)

### __`K = 3`__
![k3](img3.png)
### __`K = 5`__
![k5](img5.png)
### __`K = 7`__
![k7](img7.png)

## THỬ NGHIỆM VỚI K KHÁC
### __`K = 19`__
![k19](img19.png)

# NHẬN XÉT KẾT QUẢ
### __`K = 3`__
### `K = 5`
### `K = 7`
## THỬ NGHIỆM VỚI K KHÁC
# TÀI LIỆU THAM KHẢO

