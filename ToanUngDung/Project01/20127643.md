# __THÔNG TIN CÁ NHÂN:__ 
## `MSSV: ` __20127643__
## `HỌ VÀ TÊN:` __TRƯƠNG GIA TIẾN__<br><br>
# __Ý TƯỞNG__
## __Về KMEANS__
Về cơ bản, thuật toán KMeans là tìm ra các vị trí tối ưu, chính xác nhất của các centroid để phân cụm.<br>
__Giải thuật:__
1. Khởi tạo k centroid đầu tiên ngẫu nhiên để làm các điểm centroid bắt đầu (initial centroids)
2. Với mỗi pixel có trong ảnh, tính khoảng cách từ pixel đó tới tất cả các centroid và xác định khoảng centroid gần nhất (khoảng cách ngắn nhất tới pixel đó)
3. Tính trung bình cho từng centroid tương ứng với các pixel đã được gán vào các centroid đó
4. Update lại centroid mới tương ứng với các trung bình của nó như đã tính ở bước "3"
5. Lặp lại bước 2-3-4 cho đến khi hết số lần lặp cho phép hoặc khi centroid sau giống hoặc gần giống như centroid trước đó (hội tụ hoặc gần như hội tụ)
6. Gán các pixel với giá trị của các centroid tương ứng với chúng
<br><br>

# __CÁC HÀM__
### Hàm KMEANS
```python
def kmeans(img_1d, k_clusters, max_iter, init_centroids='random'):
    height, width, depth = img_1d.shape
    reshapedIMG = img_1d.reshape(height * width, depth)

    if init_centroids == "random":
        centroids = np.random.choice(256, size=(k_clusters, depth))
    elif init_centroids == "in_pixels":
        centroids = reshapedIMG[np.random.choice(height * width, k_clusters)] 

    for _ in range(max_iter):
        prevCentroid = centroids
        dist = np.zeros((reshapedIMG.shape[0], k_clusters))
        for k in range(k_clusters):
            vectorSubtract = np.subtract(reshapedIMG, prevCentroid[k])
            vectorNormalized = np.linalg.norm(vectorSubtract, axis=1)
            dist[:,k] = np.square(vectorNormalized)
        
        label = np.argmin(dist, axis=1) 

        for k in range(k_clusters):
            x = reshapedIMG[label == k, :]
            centroids[k,:] = np.nanmean(x, axis=0)

        if np.allclose(prevCentroid, centroids, atol=2):
            break
    
    for k in range(k_clusters):
        reshapedIMG[label == k] = centroids[k]

    reshapedIMG = reshapedIMG.reshape(height, width, depth)

    return reshapedIMG, centroids
```

### __GIẢI THÍCH HÀM KMEANS__
```python
height, width, depth = img_1d.shape
reshapedIMG = img_1d.reshape(height * width, depth)
```
Đầu tiên ta dùng hàm _`shape`_ trong `numpy` để lấy 3 thông số của ảnh là height (dòng), width (cột), depth (hay còn gọi là channel).<br>
Do ảnh RGB nếu quy ra kiểu array sẽ là mảng 3 chiều (3D) nên trước khi xử lý ta phải dùng hàm _`reshape`_ trong `numpy` để chuyển về thành mảng 2 chiều (2D)

---
```python
if init_centroids == "random":
    centroids = np.random.choice(256, size=(k_clusters, depth))
elif init_centroids == "in_pixels":
    centroids = reshapedIMG[np.random.choice(height * width, k_clusters)]
```
Tiếp đến là khởi tạo các __centroid__ ngẫu nhiên theo giá trị __k_cluster__ cho trước.<br>
Ta dùng if để kiểm tra tham số `init_centroids` truyền vào là loại gì để khởi tạo __centroid__ theo đúng ý người nhập:

- `"random"`: dùng hàm `random.choice` của `numpy` để tạo một array có __k__ dòng/vector mỗi dòng/vector có 3 phần tử tương ứng với RGB và giá trị của mỗi phần tử này sẽ được chạy random từ __0-255__
- `"in_pixels"`: dùng hàm `random.choice` của `numpy` để chọn ngẫu nhiên __k__ pixel có trong hình mà ta đã __reshape__ lại
---
```python
for _ in range(max_iter):
    prevCentroid = centroids

    dist = np.zeros((reshapedIMG.shape[0], k_clusters))
    for k in range(k_clusters):
        vectorSubtract = np.subtract(reshapedIMG, prevCentroid[k])
        vectorNormalized = np.linalg.norm(vectorSubtract, axis=1)
        dist[:,k] = np.square(vectorNormalized)
    
    label = np.argmin(dist, axis=1) 

    for k in range(k_clusters):
        x = reshapedIMG[label == k, :]
        centroids[k,:] = np.nanmean(x, axis=0)

    if np.allclose(prevCentroid, centroids, atol=2):
        break
```
Đây là vòng lặp chính và quan trọng nhất của cả hàm __Kmeans__, tác dụng của vòng lặp này  là tính toán vị trí chính xác nhất của __k centroid__ đối với các cụm pixel có trong hình ảnh.<br>
Đầu tiên gán `prevCentroid = centroids` để đến cuối vòng lặp `max_iter` ta sẽ kiểm tra sự hội tụ. 

```python
dist = np.zeros((reshapedIMG.shape[0], k_clusters))
for k in range(k_clusters):
    vectorSubtract = np.subtract(reshapedIMG, prevCentroid[k])
    vectorNormalized = np.linalg.norm(vectorSubtract, axis=1)
    dist[:,k] = np.square(vectorNormalized)
```
Khởi tạo biến `dist` là một __array__ để chứa khoảng cách của các __pixel__ so với __centroid__
Vòng lặp này dùng để tính khoảng cách giữa __pixel__ so với __k centroid__, ta không cần lồng thêm 1 vòng lặp for để tính từng pixel mà ta sẽ dùng __numpy array slicing__.



---

### MAIN
```python
def main():
    imgName = input("Enter image name: ")
    imgName = "1.jpg"
    imgExt = input("Enter image extension: ")

    img = pil.Image.open(imgName)
    npArray = np.array(img)

    k_clus = 7
    newIMG, centroids = kmeans(npArray, k_clusters=k_clus, max_iter=1000, init_centroids="in_pixels")
    
    newImgName = imgName.partition(".")[0] + str(k_clus) + "." + imgExt
    plt.imshow(newIMG)

    plt.imsave(newImgName, newIMG)

    print("Centroids: ")
    print(centroids)

    print("Image array: ")
    print(newIMG)
```
<br>

# __HÌNH ẢNH KẾT QUẢ__
## __HÌNH ẢNH GỐC__
![original](img.jpg)

### __`K = 3`__
![k3](img3.png)
### __`K = 5`__
![k5](img5.png)
### __`K = 7`__
![k7](img7.png)

## THỬ NGHIỆM VỚI K KHÁC
### __`K = 19`__
![k19](img19.png)

# NHẬN XÉT KẾT QUẢ
### __`K = 3`__
### `K = 5`
### `K = 7`
## THỬ NGHIỆM VỚI K KHÁC
# TÀI LIỆU THAM KHẢO

